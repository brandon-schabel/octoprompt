---
description: 
globs: 
alwaysApply: true
---
# Backend Architecture & FileÂ Building Guide Â (UpdatedÂ 2025â€‘04â€‘26)

This document is the **single source of truth** for how the backend of this monorepo is structured, how new capabilities should be added, and which coding conventions every file MUST follow.Â Everything below is distilled from the current codebase â€“ the examples are live snippets taken from the files you sent me so you can copyâ€‘paste them as templates.

---
## 1. Layered Architecture at a Glance

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Routes           â”‚  âžœ Hono + @hono/zod-openapi definitions
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Services         â”‚  âžœ Business logic & DB access
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Crossâ€‘Cutting Utils   â”‚  âžœ Unified AI provider, watchers, stream helpers
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Database Layer      â”‚  âžœ SQLite (bun:betterâ€‘sqlite3) + migration scripts
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
All data contracts are **declared once** as Zod schemas in `packages/shared/src/schemas/*`.  Services consume/return the *parsed* versions of those schemas, and Routes never touch raw DB rows.

- **Schema Layer:**  
  All schemas are defined in the shared package (e.g. `packages/shared/src/schemas/db-schemas.ts`). 
  The Schema files are:
  chat.schemas.ts
  common.schemas.ts
  global-state-schemas.ts
  project.schemas.ts
  provider-key.schemas.ts
  ticket-schemas.ts

- **Service Layer:**  
  The services are closely associated with the schemas, here are the follow services in `packages/server/src/services`
  chat-service.ts (Manage chat CRUD in DB as well as the AI APIs)
  project-service.ts (Manage projects, files in project, etc)
  prompt-service.ts (Service to CRUD user prompts)
  provider-key-service.ts (Manage AI provider keys)
  ticket-service.ts (Create tickets and tasks)

  There are additional services that tie into and use serveral schemas together such as 
  ai-file-change-service (service for watching for file changes and updating the database accordinly)
  cleanup-service
  file-change-plugin
  file-change-watcher (change watcher)
  file-summary-service (AI File summary service)
  file-sync-service (sync files to be)
  watchers-manager
  model-fetcher-service (for fetching ai models form the various ai model services)
  unified-provider-service (this is a very important interface for interfacing with the different AI provider)
  structured-output-service.ts (a utility for fetching typed/structured data from LLMs)



- **Route Layer:**  
API endpoints are defined with Hono, Zod with OpenAPI extension
admin-routes.ts
ai-file-change-routes.ts
chat-routes.ts
project-routes.ts
prompt-routes.ts
provider-key-routes.ts
ticket-routes.ts

| Layer | Folder | Key Files |
|-------|--------|-----------|
| Database | `packages/server/src/utils` | `database.ts` (SQLite wrapper) |
| Schemas  | `packages/shared/src/schemas` | `chat.schemas.ts`, `project.schemas.ts`, â€¦ |
| Services | `packages/server/src/services` | `chat-service.ts`, `project-service.ts`, â€¦ |
| Routes   | `packages/server/src/routes` | `chat-routes.ts`, `project-routes.ts`, â€¦ |
| Utilities| `packages/server/src/services/*-services` | `unified-provider-service.ts`, `watchers-manager.ts`, â€¦ |

> **Golden Rule**: *Raw data is converted to typed objects **once** (in the Service) and everything downstream works with those validated types.*

---
## 2. SchemaÂ Conventions Â (`packages/shared/src/schemas`)

* **Naming**Â â€“ File name ends with `.schemas.ts` and exports Zod objects **and** their `z.infer` TypeScript aliases.
* **OpenAPI**Â â€“ Every schema that crosses the network has `.openapi(<Name>)` so Swagger UI is generated automatically.
* **Example & Description**Â â€“ Provide `example` and `description` in every `.openapi({ â€¦ })` block.

```ts
// chat.schemas.ts â€“ excerpt
export const ChatSchema = z.object({
  id: z.string().openapi({ example: 'chat_1a2b3c4d' }),
  title: z.string(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
}).openapi('Chat');

export type Chat = z.infer<typeof ChatSchema>;
```

### Parameter & Body Schemas
* Path params schemas end with `ParamsSchema`; they annotate the param location via `.openapi({ param: { name, in: 'path' } })`.
* Body schemas end with `BodySchema` and live alongside the entity file.

---
## 3. ServiceÂ Pattern Â (`packages/server/src/services/*`)

* Each Service file focuses on **one domain** (Chat, Project, Promptâ€¦).
* Raw SQLite rows are converted immediately and **validated**:

```ts
// project-service.ts â€“ createProject
const row = stmt.get(...);
const projectData = {
  id: row.id,
  name: row.name,
  // â€¦
  createdAt: normalizeToIsoString(row.created_at),
  updatedAt: normalizeToIsoString(row.updated_at),
};
return ProjectSchema.parse(projectData); // Validation gate
```

* Services **never** return `any`; they return `Promise<Project>` or `Promise<Project[]>`â€”the type exported from the schema file.
* Throw `ApiError` from `shared/src` for domainâ€‘level failures; Routes decide HTTP status.

---
## 4. RouteÂ Definition Pattern Â (`packages/server/src/routes/*`)

Routes are declared in **three steps**:

1. **createRoute** âžœ declarative contract (method, path, schemas, tags).
2. **.openapi(route, handler)** âžœ attach typed implementation.
3. **Return shape** validated at compileâ€‘time via `satisfies z.infer<typeof SomeResponseSchema>`.

```ts
// chat-routes.ts â€“ GET /chats example
const getAllChatsRoute = createRoute({
  method: 'get',
  path: '/chats',
  tags: ['Chats'],
  summary: 'Get all chat sessions',
  responses: {
    200: { content: { 'application/json': { schema: ChatListResponseSchema } } },
  },
});

export const chatRoutes = new OpenAPIHono()
  .openapi(getAllChatsRoute, async c => {
    const userChats = await chatService.getAllChats();
    return c.json({
      success: true,
      data: userChats,
    } satisfies z.infer<typeof ChatListResponseSchema>, 200);
  });
```

### Streaming Endpoints
For SSE/text streaming use `hono/streaming` and the **Unified Provider Service**:

```ts
// POST /ai/chat (excerpt)
const readableStream = await handleChatMessage({ /*â€¦*/ });
return stream(c, async (s) => { await s.pipe(readableStream.toDataStream()); });
```

> **Tip**: Always set `Content-Type: text/event-stream` + `Cache-Control: no-cache` headers inside the handler.

---
## 5. Crossâ€‘CuttingÂ Utilities

| Utility | Purpose | KeyÂ API |
|---------|---------|---------|
| **unified-provider-service.ts** | Normalises calls to OpenAI, OpenRouter, Groq, etc. | `handleChatMessage(opts)` returns a **ReadableStream** for the route.
| **watchers-manager.ts** | Starts/stops fileâ€‘system watchers per project. | `startWatchingProject(project, ignoreGlobs)` |
| **file-summary-service.ts** | Creates & caches AI summaries per file. | `summarizeFiles(projectId, fileIds)` |

---
## 6. Errorâ€‘HandlingÂ Contract

* Throw `new ApiError(status, message, code, meta?)` inside services or routes.
* `app.onError()` in `packages/server/src/app.ts` converts `ApiError` to JSON: `{ error, code }`.

---
## 7. Build &Â Codeâ€‘Gen Pipeline

1. **Run server** âžœ `bun run dev` (portÂ 3147). Swagger UI at `/swagger`.
2. **Generate TS client** âžœ `bun run openapi-ts` (root). This reads the live OpenAPI doc and writes:
   * `packages/client/src/hooks/generated/*` â€“ typed fetchers & React Query wrappers.
3. **Write React Query hooks** âžœ `packages/client/src/hooks/api/*.ts` compose the generated fetcher (see `useCreateChat()` for reference).

---
## 8. TemplateÂ Snippets

### NewÂ Schema
```ts
export const ThingSchema = z.object({
  id: z.string().uuid().openapi({ example: 'thing_123' }),
  name: z.string(),
}).openapi('Thing');
export type Thing = z.infer<typeof ThingSchema>;
```

### NewÂ Service Function
```ts
export async function getThing(id: string): Promise<Thing | null> {
  const row = db.prepare('SELECT * FROM things WHERE id = ?').get(id);
  if (!row) return null;
  return ThingSchema.parse({ ...row, createdAt: normalizeToIsoString(row.created_at) });
}
```

### NewÂ Route
```ts
const getThingRoute = createRoute({
  method: 'get',
  path: '/things/{id}',
  tags: ['Things'],
  request: { params: ThingIdParamsSchema },
  responses: { 200: { content: { 'application/json': { schema: ThingResponseSchema } } } },
});

apiRoutes.openapi(getThingRoute, async c => {
  const { id } = c.req.valid('param');
  const thing = await getThing(id);
  if (!thing) throw new ApiError(404, `Thing not found: ${id}`, 'THING_NOT_FOUND');
  return c.json({ success: true, data: thing } satisfies z.infer<typeof ThingResponseSchema>, 200);
});
```

---
## 9. ChecklistÂ forÂ Every PR

- [ ] **Schema** updated + `.openapi()` added.
- [ ] **Service** returns parsed schema objects (no raw DB rows leaked).
- [ ] **Route** uses `createRoute` + `OpenAPIHono` pattern.
- [ ] Responses typed with `satisfies z.infer<â€¦>`.
- [ ] Errors thrown with `ApiError`.
- [ ] Added/updated tests (`bun test`).
- [ ] Ran `bun run openapi-ts` and committed generated client.

Happy coding! ðŸŽ‰


---
## 10. Genâ€‘AI Route Patterns

The backend exposes **three kinds of Genâ€‘AI endpoints**.  All follow the same `createRoute â†’ .openapi()` recipe, but each has its own wrinkles.

| Pattern | When to use | Key headers | Service helper |
|---------|-------------|-------------|----------------|
| **Streaming chat**  (`POST /ai/chat`) | A conversational UI that needs tokenâ€‘byâ€‘token updates (React AIÂ SDK) | `Contentâ€‘Type: text/event-stream; Cache-Control: no-cache` | `handleChatMessage()` |
| **Oneâ€‘off text generation** (`POST /ai/generate/text`) | Simple promptâ€‘in / textâ€‘out, no chat history | none (standard JSON) | `generateSingleText()` |
| **Structured output** (`POST /api/gen-ai/structured`) | Ask the model for JSON that matches a Zod schema | none | `generateStructuredData({ prompt, schema, â€¦ })` |

### 10.1  Streaming Chat Route Template (SSE)
```ts
const postAiChatRoute = createRoute({
  method: 'post',
  path: '/ai/chat',
  tags: ['AI'],
  summary: 'Chat completion (streaming)',
  request: { body: { content: { 'application/json': { schema: AiChatStreamRequestSchema } }, required: true } },
  responses: {
    200: { content: { 'text/event-stream': { schema: z.string() } } },
  },
});

export const genAiRoutes = new OpenAPIHono()
  .openapi(postAiChatRoute, async c => {
    const params = c.req.valid('json');
    c.header('Content-Type', 'text/event-stream; charset=utf-8');
    c.header('Cache-Control', 'no-cache');
    c.header('Connection', 'keep-alive');

    const streamRs = await handleChatMessage({
      chatId: params.chatId,
      userMessage: params.userMessage,
      provider: params.provider,
      options: { ...params.options, model: params.model },
      systemMessage: params.systemMessage,
    });

    return stream(c, async s => await s.pipe(streamRs.toDataStream()));
  });
```
*Keep the handler thin*: history fetch & DB writes live in `handleChatMessage()`.

### 10.2  Oneâ€‘Off Text Generation Route Template
```ts
const postGenerateTextRoute = createRoute({
  method: 'post',
  path: '/ai/generate/text',
  tags: ['AI'],
  summary: 'Generate text (nonâ€‘streaming)',
  request: { body: { content: { 'application/json': { schema: AiGenerateTextRequestSchema } }, required: true } },
  responses: { 200: { content: { 'application/json': { schema: AiGenerateTextResponseSchema } } } },
});

.genAiRoutes.openapi(postGenerateTextRoute, async c => {
  const { prompt, provider, model, options, systemMessage } = c.req.valid('json');
  const text = await generateSingleText({
    prompt,
    options: { ...options, model, provider },
    systemMessage,
  });
  return c.json({ success: true, data: { text } } satisfies z.infer<typeof AiGenerateTextResponseSchema>, 200);
});
```

### 10.3  Structured Output Route Template
```ts
const postStructuredRoute = createRoute({
  method: 'post',
  path: '/api/gen-ai/structured',
  tags: ['GenAI'],
  summary: 'Generate structured data',
  request: { body: { content: { 'application/json': { schema: AiGenerateStructuredRequestSchema } }, required: true } },
  responses: { 200: { content: { 'application/json': { schema: AiGenerateStructuredResponseSchema } } } },
});

.genAiRoutes.openapi(postStructuredRoute, async c => {
  const { schemaKey, userInput } = c.req.valid('json');
  const cfg = structuredDataSchemas[schemaKey];
  if (!cfg) throw new ApiError(400, `Invalid schemaKey: ${schemaKey}`, 'INVALID_SCHEMA_KEY');

  const prompt = cfg.promptTemplate?.replace('{userInput}', userInput) ?? userInput;
  const { object } = await generateStructuredData({ prompt, schema: cfg.schema, systemMessage: cfg.systemPrompt });

  return c.json({ success: true, data: { output: object } } satisfies z.infer<typeof AiGenerateStructuredResponseSchema>, 200);
});
```

**Dos & Donâ€™ts**
* **DO** import and reuse the response/param schemas from `shared/src/schemas/gen-ai.schemas.ts`.
* **DO** keep provider/model selection fully dynamic â€“ never hardâ€‘code OpenAI.
* **DO** bubble up errors with `throw new ApiError(status, msg, code)`.
* **DONâ€™T** leak raw service errors to the client; wrap them in `ApiError` or let `app.onError()` handle.

### 10.4  Adding More Genâ€‘AI Endpoints
1. Create/extend a Zod schema in **shared** and `.openapi()` annotate it.
2. Write a **service helper** if you need DB or provider orchestration.
3. Define the **route contract** with `createRoute`.
4. Implement with `.openapi()` using the patterns above.
5. Run `bun run openapi-ts` and commit generated client types.


## 11. Unifiedâ€¯Providerâ€¯Interface 101

The **`unified-provider-service.ts`** (a.k.a. *AI Provider Interface*) is our thin wrapper over the VercelÂ AIÂ SDK.  It exists so that **all routes talk to models the same way**, regardless of vendor.

### 11.1 What the Wrapper GivesÂ You
| Helper | Useâ€‘case | Returns |
|--------|----------|---------|
| `handleChatMessage(opts)` | Streaming chat + DB persistence | **ReadableStream** (SSEâ€‘ready) |
| `genTextStream(opts)` | One-shot prompt streaming  | ``
| `generateSingleText(opts)` | Oneâ€‘shot prompt â†’ text | `Promise<string>` |
| `generateStructuredData(opts)` | Prompt â†’ JSON that matches any Zod schema | `Promise<{ object, usage, finishReason }>` |
| `getProviderModel(provider, options)` | Lowâ€‘level access to a preâ€‘authâ€™d `LanguageModel` | `LanguageModel` |

### 11.2 Using It Properly
* **Never** call the Vercel SDK directly from a route â€“ always go through the wrapper so keys, retries, and logging are consistent.
* **Map request schemas 1â€‘toâ€‘1** with `AISdkOptions`:
  ```ts
  const unifiedOpts = { ...body.options, model: body.model };
  const text = await aiProviderInterface.generateSingleText({
    prompt: body.prompt,
    provider: body.provider,
    options: unifiedOpts,
    systemMessage: body.systemMessage,
  });
  ```
* **Provider Keys** come from the DB via `provider-key-service`.  If a key is missing the helper will fall back to envÂ vars or throw an `ApiError`.
* **Local Providers** like Ollama/LMÂ Studio are treated as OpenAIâ€‘compatible; configure `OLLAMA_BASE_URL` or `LMSTUDIO_BASE_URL` in `.env`.
* **Structured Data** â€“ always pass a Zod schema; the helper will invoke `generateObject()` and return `.object` already parsed.

### 11.3 Adding a New Provider
1. Insert a new case in `getProviderLanguageModelInterface()` that returns a VercelÂ SDK model factory.
2. Update `APIProviders` enum + DB UI so keys can be stored.
3. No route changes needed â€“ the existing endpoints accept any provider string.

```ts
case "azure_openai": {
  const apiKey = await getKey("azure_openai", debug);
  return createOpenAI({
    apiKey,
    baseURL: `https://yourâ€‘azureâ€‘endpoint.openai.azure.com/openai/deployments/gptâ€‘4o`,
    // Azure requires api-version query param â€“ configure via baseURL or interceptors.
  })(modelId);
}
```

### 11.4 Common Pitfalls
* **Missing keys** â€“ the wrapper prints a warning and most local endpoints will still work, but cloud providers will 401.
* **Wrong model name** â€“ the VercelÂ SDK throws a *model not found* error; bubble it up with `ApiError(400, â€¦, 'MODEL_NOT_FOUND')`.
* **Forgetting SSE headers** â€“ routes that pipe `handleChatMessage()` must set `Contentâ€‘Type: text/event-stream` *before* `stream()`.

---
## 12. Checklist for Every PR *(updated)*
- [ ] Schema, service, **Genâ€‘AI route**, and **Unifiedâ€¯Provider calls** follow SectionsÂ 10 &Â 11.
- [ ] Streaming endpoints send correct SSE headers.
- [ ] Structured routes validate `schemaKey` and use `generateStructuredData()`.
- [ ] Added providerâ€‘key migrations/UI if a new provider was introduced.
- [ ] â€¦ *(rest of previous checklist remains unchanged).*

